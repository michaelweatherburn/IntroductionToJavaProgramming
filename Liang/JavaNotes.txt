1) The difference between specific import and wildcard import, and the fact that there is no performance difference between the two forms of import

2) Types of errors, syntactical, semantic and logical errors

3) The fact that you cannot break a string into different lines i.e. you-
`
System.out.println("This is a <Enter>
string on two lines");

-CANNOT do this. The right way to do this is:

System.out.println("This is a " +
"string on two lines")ab
4) The time in milliseconds since the Unix Epoch (00:00:00, 01-01-1970)
is given by the method System.currentTimeMillis()

5) Math.pow(a, b) is used to calculate a raised to the power b. There are differences in the answers of a * a and Math.pow(a, 2).

6) Math.random() is used to obtain a single double value a such that 0 <= a < 1. We can extend this to obtain a whole range of random numbers. Note that if Math.random() is typecasted to an int, you'll get 0.

7) Java identifiers can contain A-Z, a-z, 0-9, _ and $ as well. An identifier can also begin with a $.

8) You can put _s between numbers to improve the readability. However the _ must be between the beginning numeral and the ending numeral of the number. So 567_798_11 is correct, while _3434 or 9090_ are wrong.

9) Assignments like

a += b;
a -= b;

and the like are called augmented assignments. There is a seemingly explicit type casting rule being applied here, since:

a op=b;

expands to
a = ( typeof(a) ) (a op b);

...and not a = a op b as one might naturally assume.

9) System.exit(status) is used to halt the JVM. Status is an integer value that is reffering to the status code you wish to pass to JVM. 0 means successfully executed, while any other interger, usually 1, indicates unsuccessful execution.

10) Using the modulus operator is also possible for floating-point numbers in Java and doing so returns remainder/divisor (yes, as a double/float value, according to the datatypes involved in the expression).

11) Java uses performance improved Logical AND and Logical OR operators. These operators are also called lazy or short-circuit operators.

p1 && p2;
p1 || p2;

p1 is evaluated first. If p1 is false, p1 && p2 will never be true, so it doesn't bother evaluating p2. Similarly if p1 is true, p1 || p2 will evaluate to true, no matter what. There is no point evaluating p2 to know its truth value.

12) The only allowed values to the input in a switch statement in Java:
byte, short, int, char, String

13) Math class has three categories of methods:
a) Trigonometric Methods
b) Exponent Methods
c) Service Methods

...and two double constants

Math.PI
Math.E

a) Trigonometric Methods:
Math.sin(rad), Math.cos(rad), Math.tan(rad) are trig functions
Math.(rad), Math.toRadians(deg) are unit converters
Math.asin(double), Math.acos(double) and Math.atan(double) are inverse trig functions

b) Exponent Methods:
Math.exp(exponent), Math.log(number), Math.log10(number), Math.pow(base, exponent), Math.sqrt(num)

c) Service Methods:
Math.abs(), Math.random(), Math.min(), Math.max(), Math.ceil(), Math.floor(), Math.rint(), Math.round() and others

14) All classes inside the java.lang package are implicitly imported into all Java files. That is why we can use the constants and methods of the  java.lang.Math class directly without having to import it.

15) Exponent Methods:
Math.log(number) takes a logarithm with Math.E as base. Math.log10() takes a logarithm with 10 as base.

16) Service Methods:
Math.rint() rounds the number toward the closest even integer if the decimal part of the input is 0.5.
Math.round() rounds the number forward when the decimal part of the input is 0.5.
Math.round(), unlike other rounding methods in the Math class, does not return an integer as a double. It:

a) returns long if the input passed to it was in the double format;
b) returns int if the input passed to it was in the float format

17) Encoding is the process of mapping a character with a corresponding (binary) number. The map itself is called an Encoding Scheme. Examples: ASCII, Unicode.
 Unicode is a 16-bit character encoding scheme. It was originally designed to have 65,535 (2^16) characters. But the current character set of Unicode has more characters called supplementary characters. But using a char variable we can only store the first 65536 Unicode characters.

18) To represent a:
a) Binary number literal, use 0B/0b as prefixes:
0B00001, 0b10101
b) Hexadecimal number literal, use 0x/0X as prefixes:
0xAB, 0X16B
c) Octal number literal, use 0 as prefix:
012 is octal 12, 12 is decimal 12.

19) To represent Unicode characters, we can use the Unicode (16-bit, or UTF-16) character convention:
\u followed by 4 hexadecimal characters to represent the Unicode character. Note that UTF-16 has since between updated to support multiple languages that were added after the 65,536 limit was crossed. The char datatype can NOT be used to directly add these characters into Java programs. But Unicode supports most Indian languages, including Hindi (and all other languages using the Devanagari Script) and Odiya.

\u0030 represents '0', \u0041 represents 'A', and so on.
The range is ideally 0000 to FFFF, but some characters from the range 0800 to 08FF are not used.

Using the \u notation, every character in the UTF-16 set can be escaped (made into an escape sequence character).

20) Methods in the Character (wrapper) class include:
a) Relational Methods:
Character.isLetter(char)
Character.isDigit(char)
Character.isLetterOrDigit(char)
Character.isUpperCase(char)
Character.isLowerCase(char)

b) Conversion Methods:
Character.toLowerCase(char)
Character.toUpperCase(char)

21) Useful basic instance (non-static) methods in the String object include:
stringObject.length(), returns the length as an int
stringObject.charAt(index), returns the char at specified index, returns int
stringObject.trim(), removes whitespaces on both ends of String, returns new String
stringObject.toUpperCase(), returns new String
stringObject.toLowerCase(), returns new String

22) In Java, both the operators + (addition) and += (augmented addition) serve as overloaded operators. The overloading is contextual.

a) If both the inputs are of the type char/numbers, then addition occurs.
b) If either or both the inputs are of type String, concatenation occurs. The input which is not of the String type is converted to its' String equivalent.

Remember that all operators in the arithmetic section of the operator precedence table have left-to-right precedence. This means that concatenation is also performed in left-to-right order. For instance:

int a = 3;
int b = 4;
System.out.println("The sum is " + a + b);

will output The sum is 34. This is because:
a) "The sum is " + 3 would be performed first. Seeing as 3 is an integer, it would be converted to its String equivalent, "3".
b) Concatenation happens. The expression is now "The sum is 3" + 4.
c) The process repeats for 4. First conversion to "4" and then concatenation. Result: "The sum is 34".

To avoid the use of LTR, use brackets, like so: ("The sum is " + (a + b));

23) The concatenation method and the plus operator can do the same thing. So,
String thirdString = firstString + secondString;
and
String thirdString = firstString.concat(secondString);
do the same thing.

24) You do NOT NEED a reference variable to carry out computations on an object. An object literal CAN be used in place of the object reference variable.

For instance,
String message = "thisPersonIsASentientBeing";
System.out.println(thisPersonIsASentientBeing.charAt(5));

is the same as:
System.out.println("thisPersonIsASentientBeing".charAt(5));

So yes, you can call non-static (instance) methods of a Class directly from that class' object literal.

25) You should not call nextLine() immediately after the methods:
nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next()

These methods (also called token-delimited methods) do not remove the delimiter called newline ('\n') from the buffer when they're done. They are designed to skip over any whitespace characters if they encounter those characters at the beginning of the buffer (i.e. before any reasonable input has begun).

nextLine(), however, is different. nextLine() is delimited ONLY by a newline character, not any other whitespace character. Also, nextLine() does not skip over any newline characters already present inside the input buffer.

26) String object methods on String Comparison include:

a) stringObject.equals(s2), checks first for reference equality, and then content equality, returns boolean
b) stringObject.equalsIgnoreCase(s2), same as above, ignores the difference between uppercase and lowercase, returns boolean
c) stringObject.compareTo(s2) Compares both strings character-by-character from beginning-to-end, scanning for differences. If a character mismatch is found, it returns the difference between the Unicode values of the two characters.

If compareTo returned 0, both strings are identical.
If compareTo returned a positive value, the character which marks the point of difference between stringObject and s2, has a higher Unicode value for StringObject than that in s2,
returns int.
d) stringObject.compareToIgnoreCase(s2) Same as above method, but does not consider the differences between uppercase and lowercase letters, returns int.
e) stringObject.startsWith(s2) Checks if s2 is a prefix (substring) of stringObject, returns boolean
f) stringObject.endsWith(s2) Checks if s2 is a suffix (substring) of StringObject, returns boolean
g) stringObject.contains(s2) Checks whether s2 is a substring of stringObject. (Literally checks whether stringObject "contains" s2).

27) String object methods on Finding Characters/Substrings are:
a) stringObject.indexOf(ch) Returns the (int) index of the first occurrence of the character ch. Checks from beginning to end (in the forward direction).
b) stringObject.indexOf(ch, fromIndex) Same as above, but checks from the index fromIndex (inclusive) to the end (in the forward direction).
c) stringObject.indexOf(s2) Same as a), but works for substrings.
d) stringObject.indexOf(s2, fromIndex) Same as b), but works for substrings.

e) stringObject.lastIndexOf(ch)
f) stringObject.lastIndexOf(ch, fromIndex)
g) stringObject.lastIndexOf(s2)
h) stringObject.lastIndexOf(s2, fromIndex)
These methods are analogous to indexOf, but check from end to beginning (in the reverse direction).

28) The System.out.printf method allows us to print formatted output the same way printf() function in C allowed us to. As an example:

System.out.printf("\n %5.2f", 12.345);
Here, the result would be 12.35.

The % symbol inside the printf method is used to mark the beginning of a format placeholder.
5 is the minimum field width specified for this number. A minimum of 5 places would be reserved for printing this number. Each character within the representation counts as one place.
2 represents the exact precision reserved for the decimal part of the number. The precision value is non-negotiable. If two units are mentioned for the precision, and there are three numbers after the decimal point in the actual number, there will be rounding off observed. If there would have been less digits in the actual number than what the precision in the format demands, the extra space after the number would be filled by adding the required number of trailing zeroes.
For minimum field width the logic is different. If there are less number of characters to occupy the minimum width (on the left hand side of the number/String/character/boolean) the extra places would be filled with blank spaces (' '). If there are more characters to represent than the minimum field width can possibly represent, that width is not observed (hence the name, MINIMUM field width).
You can also flip the way the content inside the placeholder is aligned (it is right-aligned by defult) to left-aligned by adding a minus sign directly after the % symbol. Examples:

System.out.printf("%6.2f", 34.3456);  //<blank-space>34.35  Notice that rounding off occurs, and the decimal point is also considered as taking up a place
System.out.printf("5.4e", 34.2345); //3.4235e+01    Notice the rounding off occurs. Also, since the end result includes characters such as e and the positive sign after it, the number of places used in this placeholder was 10. Which is why the minimum field width is not used.

29) Loops are programming constructs that allow you to repeat the execution of code blocks attached to them for a certain number of times.
The three types of loops central to many programming languages, among Java, are while loop, do-while loop, and for loop.

All loops have a control variable, usually a number, that controls the number of iterations the loop will run for. Also, each loop has the following phases:

1) Initialisation. This phase occurs once and "sets up" the control variable so that it can be used by the loop.
2) Conditional check. This phase causes the control value to be used in a boolean expression. If the value of that Boolean expression amounts to true, the loop will continue executing, else the loop will cease to execute and the execution context will start from the line following the conditional check (a phenomenon called "being taken out of the loop. ")
3) Update. This phase causes changes in the control variable so that it can eventually amount to false, while the setup allows the loop to run for the intended number of times, but no further. Update expressions are usually a part of the loop body (while, do-while loops) but are taken out of the loop body in the for loop.

30) A while loop has the following syntax:

initialisation;
while (conditional-check)
{
  //loop body
  statements;
  update-expression;
  //end-of-loop body
}

31) A for loop has the following syntax:

for (initialisation; conditional-check; update-expression)
{
  //loop-body
  statements;
  //end-of-loop-body
}

32) A do-while loop has the following syntax:

initialisation;
do
{
  //loop-body
  statements;
  update-expression;
  //end-of-loop-body
} while(conditional-check);

33) Loops are classified into two types:

a) Entry-controlled Loops, aka pretest loops (for, while)
b) Exit-controlled loops aka posttest loops (do..while)

For and while loops are called entry-controlled loops because the condition is checked before every iteration of the loop (yes, even the first iteration, even though that is not always obvious for the for loop.)

Do-while loop, on the other hand is called exit-controlled loop, because the conditional check is carried out at the end of each iteration. (This is why the first iteration of a do-while loop would definitely occur, since the conditional-check is not occuring before that first iteration.)

33) Loops are also classified as follows:

a) Counter-controlled loops
b) Sentinel-controlled loops

Counter-controlled loops have a counter variable that literally counts through the iterations of the loop.
Example: common for counters:
for(int i = 1; i < 5; i++)
{
  //code
}
This executes code 5 times.

Sentinel-controlled loops have a variable, which when set/deviated from a predefined value, causes the loop to terminate. Generally sentinel controlled loops are written when the programmer wants the loop to run an indeterminate number of times.
Example:
while(input != 0)
{
  input = scannerObject.nextInt();
  //more code goes here
}
In this example, the while loop will continue to run until the user has entered 0 among the inputs it has given.

34) If the loop-control variable that you're using in a for-loop will not be used anywhere else, it is a good practice to declare it inside the initialisation section of the for-loop. This will cause the variable to only have scope inside the braces of that for-loop (and, of course, the conditional-check expression/update expression as well).

It is allowed to have:

a) Multiple initialisation/declaration statements
b) Multiple update expressions/Java statements

...in a for loop. For instance:

for(int a = 10, b = 20; a < 20; a++)
  System.out.println(a + " " + b);

for(int a = 10, b = 20; a < 20; a++, b+=2)
  System.out.println(a + " " + b);

for(int a = 10, b; a < 20; a++)
  System.out.println(a + " " + b);

for(int a = 10; a < 20; System.out.println(a), a++);



If multiple initialisations/update-expressions exists, they need to be separated by commas.
However, it is not possible to have multiple conditional-checks. If you wish to have multiple conditional-checks, you can combine them using the LAND and LOR operators, as in:

for(int a = 10, b = 20; a < 20 || b < 40; a++, b+=2)
  System.out.println(a + " " + b);

It is possible to omit certain sections of the for loop altogether.

a) You can skip initialisation if the loop counter variable has already been initialised before the body of the loop.
b) You can skip update-expression if you prefer to write the update-expression inside the body of the loop.
c) Skipping the conditional-check actually means IMPLICITLY SETTING IT TO TRUE.

For instance, 

a)
int i = 5;  //initialisation already done
for(; i < 10; i++)
  System.out.println("Hello");  //prints hello 5 times

b)
int i = 5;
for(; i < 10; )
{
  System.out.println("Hello");
  i++;  //updating the loop control variable inside the loop body, as we would do for a while loop
}

c)
int i = 5;
for(; ;)
{
  System.out.println("Hello");
  i++;  //does not matter, this is an infinite loop 
}

The above loop is equivalent to:
int i = 5;
for(; true; )
{
  System.out.println("Hello");
  i++;
}

This is not the case with while() and do..while() loops. For those loops if you leave the conditional-check expression blank, an error would be thrown.
In case an infinite loop is intended, it is best to write it as such:

while(true)
{
  //loop body
}

This removes ambiguity.

35) It is allowed to omit braces for selection or iteration statements if there's only one statement inside the loop. This also applies to do-while loops.

Strangely, empty do-while loops look like this:

do {
} while(condition);

You can't omit the braces if there is no loop body.

But:

do
  statement1
while(condition);

is valid. In a do-while loop, you can omit the braces if there's only one statement inside the loop, but not if there are 0 statements inside the loop.

36) If you have the following situation

char characterValue = 10;
int doubleValue = 11;
String x;
x = y ? characterValue : doubleValue;

Here, the character will automatically get converted to a double value.
Implicit casting occurs to ensure that the final value returned by the conditional operator would not have datatype ambiguity.