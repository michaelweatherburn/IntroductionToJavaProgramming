Java:

1) The difference between specific import and wildcard import, and the fact that there is no performance difference between the two forms of import

2) Types of errors, syntactical, semantic and logical errors

3) The fact that you cannot break a string into different lines i.e. you-

System.out.println("This is a <Enter>
string on two lines");

-CANNOT do this. The right way to do this is:

System.out.println("This is a " +
"string on two lines");

4) The time in milliseconds since the Unix Epoch (00:00:00, 01-01-1970)
is given by the method System.currentTimeMillis()

5) Math.pow(a, b) is used to calculate a raised to the power b. There are differences in the answers of a * a and Math.pow(a, 2).

6) Math.random() is used to obtain a single double value a such that 0 <= a < 1. We can extend this to obtain a whole range of random numbers. Note that if Math.random() is typecasted to an int, you'll get 0.

7) Java identifiers can contain A-Z, a-z, 0-9, _ and $ as well. An identifier can also begin with a $.

8) You can put _s between numbers to improve the readability. However the _ must be between the beginning numeral and the ending numeral of the number. So 567_798_11 is correct, while _3434 or 9090_ are wrong.

9) Assignments like

a += b;
a -= b;

and the like are called augmented assignments. There is a seemingly explicit type casting rule being applied here, since:

a op=b;

expands to
a = ( typeof(a) ) (a op b);

...and not a = a op b as one might naturally assume.

9) System.exit(status) is used to halt the JVM. Status is an integer value that is reffering to the status code you wish to pass to JVM. 0 means successfully executed, while any other interger, usually 1, indicates unsuccessful execution.

10) Using the modulus operator is also possible for floating-point numbers in Java and doing so returns remainder/divisor (yes, as a double/float value, according to the datatypes involved in the expression).

11) Java uses performance improved Logical AND and Logical OR operators. These operators are also called lazy or short-circuit operators.

p1 && p2;
p1 || p2;

p1 is evaluated first. If p1 is false, p1 && p2 will never be true, so it doesn't bother evaluating p2. Similarly if p1 is true, p1 || p2 will evaluate to true, no matter what. There is no point evaluating p2 to know its truth value.

12) The only allowed values to the input in a switch statement in Java:
byte, short, int, char, String

13) Math class has three categories of methods:
a) Trigonometric Methods
b) Exponent Methods
c) Service Methods

...and two double constants

Math.PI
Math.E

a) Trigonometric Methods:
Math.sin(rad), Math.cos(rad), Math.tan(rad) are trig functions
Math.(rad), Math.toRadians(deg) are unit converters
Math.asin(double), Math.acos(double) and Math.atan(double) are inverse trig functions

b) Exponent Methods:
Math.exp(exponent), Math.log(number), Math.log10(number), Math.pow(base, exponent), Math.sqrt(num)

c) Service Methods:
Math.abs(), Math.random(), Math.min(), Math.max(), Math.ceil(), Math.floor(), Math.rint(), Math.round() and others

14) All classes inside the java.lang package are implicitly imported into all Java files. That is why we can use the constants and methods of the  java.lang.Math class directly without having to import it.

15) Exponent Methods:
Math.log(number) takes a logarithm with Math.E as base. Math.log10() takes a logarithm with 10 as base.

16) Service Methods:
Math.rint() rounds the number toward the closest even integer if the decimal part of the input is 0.5.
Math.round() rounds the number forward when the decimal part of the input is 0.5.
Math.round(), unlike other rounding methods in the Math class, does not return an integer as a double. It:

a) returns long if the input passed to it was in the double format;
b) returns int if the input passed to it was in the float format

17) Encoding is the process of mapping a character with a corresponding (binary) number. The map itself is called an Encoding Scheme. Examples: ASCII, Unicode.
 Unicode is a 16-bit character encoding scheme. It was originally designed to have 65,535 (2^16) characters. But the current character set of Unicode has more characters called supplementary characters. But using a char variable we can only store the first 65536 Unicode characters.

18) To represent a:
a) Binary number literal, use 0B/0b as prefixes:
0B00001, 0b10101
b) Hexadecimal number literal, use 0x/0X as prefixes:
0xAB, 0X16B
c) Octal number literal, use 0 as prefix:
012 is octal 12, 12 is decimal 12.

19) To represent Unicode characters, we can use the Unicode (16-bit, or UTF-16) character convention:
\u followed by 4 hexadecimal characters to represent the Unicode character. Note that UTF-16 has since between updated to support multiple languages that were added after the 65,536 limit was crossed. The char datatype can NOT be used to directly add these characters into Java programs. But Unicode supports most Indian languages, including Hindi (and all other languages using the Devanagari Script) and Odiya.

\u0030 represents '0', \u0041 represents 'A', and so on.
The range is ideally 0000 to FFFF, but some characters from the range 0800 to 08FF are not used.

Using the \u notation, every character in the UTF-16 set can be escaped (made into an escape sequence character).

20) Methods in the Character (wrapper) class include:
a) Relational Methods:
Character.isLetter(char)
Character.isDigit(char)
Character.isLetterOrDigit(char)
Character.isUpperCase(char)
Character.isLowerCase(char)

b) Conversion Methods:
Character.toLowerCase(char)
Character.toUpperCase(char)

21) Useful instance (non-static) methods in the String object include:
stringObject.length()
stringObject.charAt(index)
stringObject.trim()
stringObject.toUpperCase()
stringObject.toLowerCase()


22) In Java, both the operators + (addition) and += (augmented addition) serve as overloaded operators. The overloading is contextual.

a) If both the inputs are of the type char/numbers, then addition occurs.
b) If either or both the inputs are of type String, concatenation occurs. The input which is not of the String type is converted to its' String equivalent.

Remember that all operators in the arithmetic section of the operator precedence table have left-to-right precedence. This means that concatenation is also performed in left-to-right order. For instance:

int a = 3;
int b = 4;
System.out.println("The sum is " + a + b);

will output The sum is 34. This is because:
a) "The sum is " + 3 would be performed first. Seeing as 3 is an integer, it would be converted to its String equivalent, "3".
b) Concatenation happens. The expression is now "The sum is 3" + 4.
c) The process repeats for 4. First conversion to "4" and then concatenation. Result: "The sum is 34".

To avoid the use of LTR, use brackets, like so: ("The sum is " + (a + b));

23) The concatenation method and the plus operator can do the same thing. So,
String thirdString = firstString + secondString;
and
String thirdString = firstString.concat(secondString);
do the same thing.

24) You do NOT NEED a reference variable to carry out computations on an object. An object literal CAN be used in place of the object reference variable.

For instance,
String message = "thisPersonIsASentientBeing";
System.out.println(thisPersonIsASentientBeing.charAt(5));

is the same as:
System.out.println("thisPersonIsASentientBeing".charAt(5));

So yes, you can call non-static (instance) methods of a Class directly from that class' object literal.

25) You should not call nextLine() immediately after the methods:
nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next()

This is because of the other methods leaving the newline character intact, which is unfortunately picked up by nextLine().
