1) The difference between specific import and wildcard import, and the fact that there is no performance difference between the two forms of import

2) Types of errors, syntactical, semantic and logical errors

3) The fact that you cannot break a string into different lines i.e. you-
`
System.out.println("This is a <Enter>
string on two lines");

-CANNOT do this. The right way to do this is:

System.out.println("This is a " +
"string on two lines")ab
4) The time in milliseconds since the Unix Epoch (00:00:00, 01-01-1970)
is given by the method System.currentTimeMillis()

5) Math.pow(a, b) is used to calculate a raised to the power b. There are differences in the answers of a * a and Math.pow(a, 2).

6) Math.random() is used to obtain a single double value a such that 0 <= a < 1. We can extend this to obtain a whole range of random numbers. Note that if Math.random() is typecasted to an int, you'll get 0.

7) Java identifiers can contain A-Z, a-z, 0-9, _ and $ as well. An identifier can also begin with a $.

8) You can put _s between numbers to improve the readability. However the _ must be between the beginning numeral and the ending numeral of the number. So 567_798_11 is correct, while _3434 or 9090_ are wrong.

9) Assignments like

a += b;
a -= b;

and the like are called augmented assignments. There is a seemingly explicit type casting rule being applied here, since:

a op=b;

expands to
a = ( typeof(a) ) (a op b);

...and not a = a op b as one might naturally assume.

9) System.exit(status) is used to halt the JVM. Status is an integer value that is reffering to the status code you wish to pass to JVM. 0 means successfully executed, while any other interger, usually 1, indicates unsuccessful execution.

10) Using the modulus operator is also possible for floating-point numbers in Java and doing so returns remainder/divisor (yes, as a double/float value, according to the datatypes involved in the expression).

11) Java uses performance improved Logical AND and Logical OR operators. These operators are also called lazy or short-circuit operators.

p1 && p2;
p1 || p2;

p1 is evaluated first. If p1 is false, p1 && p2 will never be true, so it doesn't bother evaluating p2. Similarly if p1 is true, p1 || p2 will evaluate to true, no matter what. There is no point evaluating p2 to know its truth value.

12) The only allowed values to the input in a switch statement in Java:
byte, short, int, char, String

13) Math class has three categories of methods:
a) Trigonometric Methods
b) Exponent Methods
c) Service Methods

...and two double constants

Math.PI
Math.E

a) Trigonometric Methods:
Math.sin(rad), Math.cos(rad), Math.tan(rad) are trig functions
Math.(rad), Math.toRadians(deg) are unit converters
Math.asin(double), Math.acos(double) and Math.atan(double) are inverse trig functions

b) Exponent Methods:
Math.exp(exponent), Math.log(number), Math.log10(number), Math.pow(base, exponent), Math.sqrt(num)

c) Service Methods:
Math.abs(), Math.random(), Math.min(), Math.max(), Math.ceil(), Math.floor(), Math.rint(), Math.round() and others

14) All classes inside the java.lang package are implicitly imported into all Java files. That is why we can use the constants and methods of the  java.lang.Math class directly without having to import it.

15) Exponent Methods:
Math.log(number) takes a logarithm with Math.E as base. Math.log10() takes a logarithm with 10 as base.

16) Service Methods:
Math.rint() rounds the number toward the closest even integer if the decimal part of the input is 0.5.
Math.round() rounds the number forward when the decimal part of the input is 0.5.
Math.round(), unlike other rounding methods in the Math class, does not return an integer as a double. It:

a) returns long if the input passed to it was in the double format;
b) returns int if the input passed to it was in the float format

17) Encoding is the process of mapping a character with a corresponding (binary) number. The map itself is called an Encoding Scheme. Examples: ASCII, Unicode.
 Unicode is a 16-bit character encoding scheme. It was originally designed to have 65,535 (2^16) characters. But the current character set of Unicode has more characters called supplementary characters. But using a char variable we can only store the first 65536 Unicode characters.

18) To represent a:
a) Binary number literal, use 0B/0b as prefixes:
0B00001, 0b10101
b) Hexadecimal number literal, use 0x/0X as prefixes:
0xAB, 0X16B
c) Octal number literal, use 0 as prefix:
012 is octal 12, 12 is decimal 12.

19) To represent Unicode characters, we can use the Unicode (16-bit, or UTF-16) character convention:
\u followed by 4 hexadecimal characters to represent the Unicode character. Note that UTF-16 has since between updated to support multiple languages that were added after the 65,536 limit was crossed. The char datatype can NOT be used to directly add these characters into Java programs. But Unicode supports most Indian languages, including Hindi (and all other languages using the Devanagari Script) and Odiya.

\u0030 represents '0', \u0041 represents 'A', and so on.
The range is ideally 0000 to FFFF, but some characters from the range 0800 to 08FF are not used.

Using the \u notation, every character in the UTF-16 set can be escaped (made into an escape sequence character).

20) Methods in the Character (wrapper) class include:
a) Relational Methods:
Character.isLetter(char)
Character.isDigit(char)
Character.isLetterOrDigit(char)
Character.isUpperCase(char)
Character.isLowerCase(char)

b) Conversion Methods:
Character.toLowerCase(char)
Character.toUpperCase(char)

21) Useful basic instance (non-static) methods in the String object include:
stringObject.length(), returns the length as an int
stringObject.charAt(index), returns the char at specified index, returns int
stringObject.trim(), removes whitespaces on both ends of String, returns new String
stringObject.toUpperCase(), returns new String
stringObject.toLowerCase(), returns new String

22) In Java, both the operators + (addition) and += (augmented addition) serve as overloaded operators. The overloading is contextual.

a) If both the inputs are of the type char/numbers, then addition occurs.
b) If either or both the inputs are of type String, concatenation occurs. The input which is not of the String type is converted to its' String equivalent.

Remember that all operators in the arithmetic section of the operator precedence table have left-to-right precedence. This means that concatenation is also performed in left-to-right order. For instance:

int a = 3;
int b = 4;
System.out.println("The sum is " + a + b);

will output The sum is 34. This is because:
a) "The sum is " + 3 would be performed first. Seeing as 3 is an integer, it would be converted to its String equivalent, "3".
b) Concatenation happens. The expression is now "The sum is 3" + 4.
c) The process repeats for 4. First conversion to "4" and then concatenation. Result: "The sum is 34".

To avoid the use of LTR, use brackets, like so: ("The sum is " + (a + b));

23) The concatenation method and the plus operator can do the same thing. So,
String thirdString = firstString + secondString;
and
String thirdString = firstString.concat(secondString);
do the same thing.

24) You do NOT NEED a reference variable to carry out computations on an object. An object literal CAN be used in place of the object reference variable.

For instance,
String message = "thisPersonIsASentientBeing";
System.out.println(thisPersonIsASentientBeing.charAt(5));

is the same as:
System.out.println("thisPersonIsASentientBeing".charAt(5));

So yes, you can call non-static (instance) methods of a Class directly from that class' object literal.

25) You should not call nextLine() immediately after the methods:
nextByte(), nextShort(), nextInt(), nextLong(), nextFloat(), nextDouble(), next()

These methods (also called token-delimited methods) do not remove the delimiter called newline ('\n') from the buffer when they're done. They are designed to skip over any whitespace characters if they encounter those characters at the beginning of the buffer (i.e. before any reasonable input has begun).

nextLine(), however, is different. nextLine() is delimited ONLY by a newline character, not any other whitespace character. Also, nextLine() does not skip over any newline characters already present inside the input buffer.

26) String object methods on String Comparison include:

a) stringObject.equals(s2), checks first for reference equality, and then content equality, returns boolean
b) stringObject.equalsIgnoreCase(s2), same as above, ignores the difference between uppercase and lowercase, returns boolean
c) stringObject.compareTo(s2) Compares both strings character-by-character from beginning-to-end, scanning for differences. If a character mismatch is found, it returns the difference between the Unicode values of the two characters.

If compareTo returned 0, both strings are identical.
If compareTo returned a positive value, the character which marks the point of difference between stringObject and s2, has a higher Unicode value for StringObject than that in s2,
returns int.
d) stringObject.compareToIgnoreCase(s2) Same as above method, but does not consider the differences between uppercase and lowercase letters, returns int.
e) stringObject.startsWith(s2) Checks if s2 is a prefix (substring) of stringObject, returns boolean
f) stringObject.endsWith(s2) Checks if s2 is a suffix (substring) of StringObject, returns boolean
g) stringObject.contains(s2) Checks whether s2 is a substring of stringObject. (Literally checks whether stringObject "contains" s2).

27) String object methods on Finding Characters/Substrings are:
a) stringObject.indexOf(ch) Returns the (int) index of the first occurrence of the character ch. Checks from beginning to end (in the forward direction).
b) stringObject.indexOf(ch, fromIndex) Same as above, but checks from the index fromIndex (inclusive) to the end (in the forward direction).
c) stringObject.indexOf(s2) Same as a), but works for substrings.
d) stringObject.indexOf(s2, fromIndex) Same as b), but works for substrings.

e) stringObject.lastIndexOf(ch)
f) stringObject.lastIndexOf(ch, fromIndex)
g) stringObject.lastIndexOf(s2)
h) stringObject.lastIndexOf(s2, fromIndex)
These methods are analogous to indexOf, but check from end to beginning (in the reverse direction).

28) The System.out.printf method allows us to print formatted output the same way printf() function in C allowed us to. As an example:

System.out.printf("\n %5.2f", 12.345);
Here, the result would be 12.35.

The % symbol inside the printf method is used to mark the beginning of a format placeholder.
5 is the minimum field width specified for this number. A minimum of 5 places would be reserved for printing this number. Each character within the representation counts as one place.
2 represents the exact precision reserved for the decimal part of the number. The precision value is non-negotiable. If two units are mentioned for the precision, and there are three numbers after the decimal point in the actual number, there will be rounding off observed. If there would have been less digits in the actual number than what the precision in the format demands, the extra space after the number would be filled by adding the required number of trailing zeroes.
For minimum field width the logic is different. If there are less number of characters to occupy the minimum width (on the left hand side of the number/String/character/boolean) the extra places would be filled with blank spaces (' '). If there are more characters to represent than the minimum field width can possibly represent, that width is not observed (hence the name, MINIMUM field width).
You can also flip the way the content inside the placeholder is aligned (it is right-aligned by defult) to left-aligned by adding a minus sign directly after the % symbol. Examples:

System.out.printf("%6.2f", 34.3456);  //<blank-space>34.35  Notice that rounding off occurs, and the decimal point is also considered as taking up a place
System.out.printf("5.4e", 34.2345); //3.4235e+01    Notice the rounding off occurs. Also, since the end result includes characters such as e and the positive sign after it, the number of places used in this placeholder was 10. Which is why the minimum field width is not used.

When the precision specified is lower than the number of digits in the input floating-point number, rounding or truncation occurs (rounding if the left-most digit left behind after truncation is > 5, truncation otherwise).

Input must match the format specifiers in exact type.
The input passed to:
%b - boolean (boolean)
%c - character (char)
%d - integer number (int/long)
%e, %f - floating-point number (float/double) in either notation (regular/scientific)

The % character signifies the beginning of a format specifier in a format string. To use the '%'' character literal in a format string, we need to escape the character with itself (no, backslash is not used for this character).

%% is the right way to display a single '%' in a format string.

29) Loops are programming constructs that allow you to repeat the execution of code blocks attached to them for a certain number of times.
The three types of loops central to many programming languages, among Java, are while loop, do-while loop, and for loop.

All loops have a control variable, usually a number, that controls the number of iterations the loop will run for. Also, each loop has the following phases:

1) Initialisation. This phase occurs once and "sets up" the control variable so that it can be used by the loop.
2) Conditional check. This phase causes the control value to be used in a boolean expression. If the value of that Boolean expression amounts to true, the loop will continue executing, else the loop will cease to execute and the execution context will start from the line following the conditional check (a phenomenon called "being taken out of the loop. ")
3) Update. This phase causes changes in the control variable so that it can eventually amount to false, while the setup allows the loop to run for the intended number of times, but no further. Update expressions are usually a part of the loop body (while, do-while loops) but are taken out of the loop body in the for loop.

30) A while loop has the following syntax:

initialisation;
while (conditional-check)
{
  //loop body
  statements;
  update-expression;
  //end-of-loop body
}

31) A for loop has the following syntax:

for (initialisation; conditional-check; update-expression)
{
  //loop-body
  statements;
  //end-of-loop-body
}

32) A do-while loop has the following syntax:

initialisation;
do
{
  //loop-body
  statements;
  update-expression;
  //end-of-loop-body
} while(conditional-check);

33) Loops are classified into two types:

a) Entry-controlled Loops, aka pretest loops (for, while)
b) Exit-controlled loops aka posttest loops (do..while)

For and while loops are called entry-controlled loops because the condition is checked before every iteration of the loop (yes, even the first iteration, even though that is not always obvious for the for loop.)

Do-while loop, on the other hand is called exit-controlled loop, because the conditional check is carried out at the end of each iteration. (This is why the first iteration of a do-while loop would definitely occur, since the conditional-check is not occuring before that first iteration.)

33) Loops are also classified as follows:

a) Counter-controlled loops
b) Sentinel-controlled loops

Counter-controlled loops have a counter variable that literally counts through the iterations of the loop.
Example: common for counters:
for(int i = 1; i < 5; i++)
{
  //code
}
This executes code 5 times.

Sentinel-controlled loops have a variable, which when set/deviated from a predefined value, causes the loop to terminate. Generally sentinel controlled loops are written when the programmer wants the loop to run an indeterminate number of times.
Example:
while(input != 0)
{
  input = scannerObject.nextInt();
  //more code goes here
}
In this example, the while loop will continue to run until the user has entered 0 among the inputs it has given.

34) If the loop-control variable that you're using in a for-loop will not be used anywhere else, it is a good practice to declare it inside the initialisation section of the for-loop. This will cause the variable to only have scope inside the braces of that for-loop (and, of course, the conditional-check expression/update expression as well).

It is allowed to have:

a) Multiple initialisation/declaration statements
b) Multiple update expressions/Java statements

...in a for loop. For instance:

for(int a = 10, b = 20; a < 20; a++)
  System.out.println(a + " " + b);

for(int a = 10, b = 20; a < 20; a++, b+=2)
  System.out.println(a + " " + b);

for(int a = 10, b; a < 20; a++)
  System.out.println(a + " " + b);

for(int a = 10; a < 20; System.out.println(a), a++);



If multiple initialisations/update-expressions exists, they need to be separated by commas.
However, it is not possible to have multiple conditional-checks. If you wish to have multiple conditional-checks, you can combine them using the LAND and LOR operators, as in:

for(int a = 10, b = 20; a < 20 || b < 40; a++, b+=2)
  System.out.println(a + " " + b);

It is possible to omit certain sections of the for loop altogether.

a) You can skip initialisation if the loop counter variable has already been initialised before the body of the loop.
b) You can skip update-expression if you prefer to write the update-expression inside the body of the loop.
c) Skipping the conditional-check actually means IMPLICITLY SETTING IT TO TRUE.

For instance, 

a)
int i = 5;  //initialisation already done
for(; i < 10; i++)
  System.out.println("Hello");  //prints hello 5 times

b)
int i = 5;
for(; i < 10; )
{
  System.out.println("Hello");
  i++;  //updating the loop control variable inside the loop body, as we would do for a while loop
}

c)
int i = 5;
for(; ;)
{
  System.out.println("Hello");
  i++;  //does not matter, this is an infinite loop 
}

The above loop is equivalent to:
int i = 5;
for(; true; )
{
  System.out.println("Hello");
  i++;
}

This is not the case with while() and do..while() loops. For those loops if you leave the conditional-check expression blank, an error would be thrown.
In case an infinite loop is intended, it is best to write it as such:

while(true)
{
  //loop body
}

This removes ambiguity.

35) It is allowed to omit braces for selection or iteration statements if there's only one statement inside the loop. This also applies to do-while loops.

Strangely, empty do-while loops look like this:

do {
} while(condition);

You can't omit the braces if there is no loop body.

But:

do
  statement1
while(condition);

is valid. In a do-while loop, you can omit the braces if there's only one statement inside the loop, but not if there are 0 statements inside the loop.

36) If you have the following situation

char characterValue = 10;
int doubleValue = 11;
String x;
x = y ? characterValue : doubleValue;

Here, the character will automatically get converted to a double value.
Implicit casting occurs to ensure that the final value returned by the conditional operator would not have datatype ambiguity.

37) Loop control statements break and continue

a) break statement brings the execution control directly out of the loop
b) continue statement skips over the rest of the statements in the current iteration
c)

In while and do-while loops, on execution of a continue statement, the loop-continuation-condition preceding the next iteration is directly executed. In a for loop, the action-after-each-iteration following the lines of code that were skipped is executed first. continue ONLY skips over the REST OF THE LOOP BODY in the current iteration - it doesn't impact anything in the loop flowchart.

38) There are parse methods present within wrapper classes to convert any valid String value to a valid corresponding primitive datatype.

Byte.parseByte("validByte")
Short.parseShort("validShort");
Integer.parseInt("validInteger");
Long.parseLong("validLong");
Float.parseFloat("validFloat");
Double.parseDouble("validDouble");

39) Methods are reusable entities which house business logic within them. Once defined, methods can be invoked as required. There are three parts to using a method:

Method Declaration/Method Prototype
Method Definition
Method Invocation/Method Call

40) Syntax for Method Definition:

methodHeader {
  methodBody;
  // contains multiple statements
  return result;  // this is the return statement
}

Where the methodHeader is as follows:
modifier returnTypeValue methodName(dataType1 formalParameter1, dataType2 formalParameter2...)

41)
The modifier provides contextual information about the method.

 A method in Java is a programming language construct that mirrors the mathematical construct called functions. In mathematics, functions are supposed to return a single unambiguous value. Multiple values are not allowed, and the value must be defined. Just like mathematical functions, methods in Java may return values, if they're defined so. Based on this, there are two kinds of methods:

a) Value-returning method
The method returns a value (of any primitive or reference type). Mathematically saying this means "providing a unique answer". The returnValueType can then contain any valid Java datatype or class, like int, double, boolean, String, ArrayList<String>, or Student. Programming constructs like these are called functions in other languages.

Example of value-returning method:

public static int sign(int inputNumber)
{
  if (inputNumber > 0)
    return 1;
  else if (inputNumber == 0)
    return 0;
  else
    return -1;
}

In order to be a value-returning method, a statement containing the return keyword must be present in all possible flows of the method. No matter what the flow within the method is, the return statement/statements must be reachable.

public static int sign(int inputNumber)
{
  if (inputNumber > 0)
    return 1;
  else if (inputNumber == 0)
    return 0;
  else if (inputNumber < 0)
    return -1;
}

This syntax throws an error, because the compiler thinks that there is a possiblity that none of the if-clauses match, in which case, no return statement is reached. (Since the compiler only checks for syntax, not for semantics, it is not smart enough to realise that the cases themselves, i.e. inputNumber > 0, inputNumber == 0, and inputNumber < 0 are mutually exclusive and cover all possibilities of the integer inputNumber. This is why this code, although semantically perfect, won't run. The proper way to write this code would be:

public static int sign(int inputNumber)
{
  int result = -2;
  if (inputNumber > 0)
    result = 1;
  else if (inputNumber == 0)
    result = 0;
  else if (inputNumber < 0)
    result = -1;
  return result;
}

By separating the variable result from the rest of the code, we've ensured that the return statement would be executed regardless of the flow of the method. The initial value of -2 is used because it is not possible to return a value (or use it in any other way) without initializing it, and the compiler (because of the aforementioned reasons) detects the possibility that the variable result might not have been initialized (again, the compiler doesn't understand semantics so it doesn't get the fact that all possible values of inputNumber have been covered by the mutually exclusive if-conditions in the if-else ladder)

b) void method

When a method is designed not to return any value, it is known as a void method. Programming constructs like these are called procedures in other languages. The void method must have a returnValueType of void.

Example of void method:

public static void printWelcome() {
  System.out.println("Welcome!");
}

This method prints a fixed String to the console, but doesn't return any value.
Return statements can also be used in void methods, to prematurely terminating the method and returning the execution control back to the caller. For example, 

public static void addAndPrintPositiveIntegers(int i1, int i2)
{
  if (i1 < 0 || i2 < 0)
  {
      System.out.println("One or both the integers provided as input are negative. Sum not calculated. ");
      return;
  }
  return (i1 + i2);
}

42) Methods cannot exist independently of classes in Java. Method definitions have to be encapsulated inside class definitions.
Inside classes, methods perform two roles, which defines whether the modifier "static" would be assigned to them.

a) Static Methods - These methods are written on the "class level". They are independent of any objects that the class might have, although they can be executed using an object.

Static Methods' Invocation Syntax:

1) ClassName.staticMethodName(list-of-actual-parameters);
(The proper way to invoke a method which can be accessed by current class, but is NOT defined within the current class)
2) staticMethodName(list-of-actual-parameters);
(only if the class is being invoked within the same class as when it is defined)
3) objectName.staticMethodName(list-of-actual-parameters);
(This is possible, but not advisble. Static methods are supposed to be independent of objects. Business logic within those classes should not be related to object-level data members)

b) Instance Methods - These methods are written on the "object/instance level" and are tied to the instance of the class that invokes them, and these methods usually use the said instance as context for execution.

Instance Methods' Invocation Syntax:

objectName.staticMethodName(list-of-actual-parameters);

43) When a method is called, the values of the actual parameters (arguments) are used to initalize the formal parameters (parameters). A copy of each actual parameter is created and assigned to the corresponding formal parameter. This is called Pass By Value.

For pass-by-value to happen, the arguments provided in the method invocation must have been provided in the same order as that of the corresponding parameters in the method definition's signature. This is called parameter order association. This is necessary because we need formal parameters and actual parameters to have a one-to-one correspondence for the values to be copied over.

The list of parameters must match the list of arguments exactly in
a) Order
b) Number
c) Compatible Type

Examples:
public static void increaseGrade(char currentGrade, int numberOfGradesToIncrease) // method header

// Method invocation - Valid examples
increaseGrade('A', 1);
increaseGrade('B', 2);

// Method Invocation - Invalid examples
increaseGrade(1, 'A'); // Parameter order association does not hold - the order of the arguments does not match the order of the parameters
increaseGrade(145L, 1);
increaseGrade(4.5, 2);  // Incompatible type  - the first long/double argument can not be implicitly cast to a char value
increaseGrade('A'); // Number of arguments are different - the number of arguments does not match the number of parameters

44) Pass-by-value causes new memory to be created for each formal parameter. This memory is created inside the activation frame of the method that was called. After that, the values of the actual parameters are copied to the formal parameters in a one-to-one fashion. After that, all changes made to the parameters will exist only for the length of the method that was called. As soon as the method is finished executing, the activation frame of the called method is removed from the call stack, and so do the values of the formal parameters. The actual parameters cannot be changed by this call.

Example:

public class SwapLogic {
  public static void swap (int i1, int i2)
  {
    int temp = i1;
    i1 = i2;
    i2 = temp;
    System.out.println("First Value: " + i1 + ", Second Value: " + i2);
  }

  public static void main(String[] args)
  {
    int firstArgument = 1;
    int secondArgument = 2;
    System.out.println("First Value: " + firstArgument + ", Second Value: " + secondArgument);
    swap(firstArgument, secondArgument);
    System.out.println("First Value: " + firstArgument + ", Second Value: " + secondArgument);
  }
}

Here, the values of the variables firstArgument and secondArgument would be used to initialize the values of i1 and i2. The values i1 and i2 (present in the activation record corresponding to swap) would be swapped using a third variable. After that, the control returns to main from swap, as the activation record for swap is removed when swap finishes execution. The values firstArgument and secondArgument, present in the activation record corresponding to main, remain unaffected by the events that occurred within swap.

That is why the values aren't swapped in the main method. However, if you check the values in the swap method after its execution, the values would be swapped.

45) A method and a variable can have the same name within the same scope. The compiler doesn't confuse between the two. That is because the invocation of a method has fundamentally different syntax:

a) ClassName.methodName(list-of-arguments)
b) objectName.methodName(list-of-arguments)
c) methodName(list-of-arguments)

...than that of a variable when it is used in an expression/statement:

variableName

However, two variables, even of different types, cannot have the same name. On trying to declare the second variable with the same name, the compiler would show an error - variable already declared.

46) Method Overloading
Multiple methods within a class can have the same name, but different definitions. This is possible if the method signatures of the methods are different. The method signature is:

methodName(datatype1 formalParameter1, datatype2 formalParameter2...)

In other words, the method signature is characterized by:
a) the method's name
b) the number of formal parameters
c) the order of formal parameters
d) the datatype of each formal parameter

In order for methods to have the same name, one or more of the other three properties that characterize the method must be different. Here's an example of method overloading:

public static int sum(int firstNumber, int secondNumber) {
  return firstNumber + secondNumber;
}

public static double sum(double firstNumber, double secondNumber) {
  return firstNumber + secondNumber;
}

Note that for method overloading to work, the method signature must be unique. Modifiers and returntypes don't form part of the method signature, so having the same method signature but different returntypes/modifiers would result in a compiler error.

47) If there are two definitions of an overloaded method, and the compiler is confused about which definition to adhere to when calling the method, owing to the nature of the actual parameters provided, this is called ambiguous invocation.

/* Method Definitions */
public static double sum(int firstNumber, double secondNumber)
{
  return (firstNumber + secondNumber);
}

public static double sum(double firstNumber, int secondNumber)
{
  return (firstNumber + secondNumber);
}

/* Method Invocation */
sum(3,4);

Just as 3, the integer argument is a compatible type for the first parameter of the second definition, 4, the integer argument is a compatible type for the second argument of the first method. The compiler sees the two method definitions as equally plausible. This is called ambiguous invocation.
The error shown would be:

Reference to <methodName> is ambiguous

48) For loop has the following syntax:

for (initial-action; loop-continuation-condition; action-after-each-iteration)
{
  // loop body
}

initial-action - any variable declared within this portion of the for loop will have the scope of the entire for loop (all the iterations of the for loop). This makes the for loop different from the while and do-while loop - there is no area where you can create variables that are not exclusive to each loop block, but are shared across all iterations.

For example:

for (int i = 1; i < 10; i++)  // Here, the variable i has a scope that covers all blocks (across all iterations) of the for loop
{
  boolean b = false;  // This variable is BEING DECLARED and assigned, again and again in each loop iteration (since all loop iterations have separate blocks) and the value's scope ends at the end of each loop block
  System.out.println(i);  
}

49) 